#+title: Translating ixml grammars into schemas
#+author: CMSMcQ 
#+date: 9 July 2024

An Invisible XML grammar /G/ describes both a set of strings and a
mapping from those strings to XML documents.  Just as not every string
is a member of the language described by the grammar /G/, so also not
every XML document is a member of the set of documents which may be
emitted by a conforming processor parsing some sentence in that
language against /G/.  It is conventional to denote the set of
sentences accepted by /G/ with the expression /L(G)/; analogously, we
can refer to the set of XML documents produced by /G/ with the
expression /X(G)/.

We can decide whether a string /s/ is a member of /L(G)/ or not by
parsing /s/ against /G/.  Can we similarly decide whether an XML
document /D/ is a member of /X(G)/?  In particular, can we construct a
schema /S/ that accepts as schema-valid all and only the documents in
/X(G)/?  If we can, how can we do so?  This would be convenient in
cases where we wish to start with some string /s/ which is an
expression in some notation /N/ for which we can construct an ixml
grammar /G/, use an ixml processor to convert /s/ into some XML
document /d/, use XML tools to modify /d/ to create some document
/d′/, and then re-serialize /d′/ as an expression /s′/ in notation
/N/.  Having a schema for the set /X(G)/ would help ensure that
document /d′/ can be successfully re-serialized in notation /N/.

If we cannot construct a schema /S/ that accepts all and only the
members of /X(G)/, then can we construct some reasonably satisfactory
approximation of /S/, which will correctly distinguish members of
/X(G)/ from non-members most of the time?

The short answer is: we cannot always construct a schema that matches
/X(G)/ perfectly, but we can come close enough to make the schema
useful, and for some grammars and some schema languages /X(G)/ can be
recognized.

This document discusses these questions and shows how to construct
schemas that approximate language /X(G)/.  It distinguishes a number
of different ways to approximate language /X(G)/ in a schema, and
describes in varying amounts of detail how to construct such schemas.

* Some preliminary definitions and assumptions

Some names are used here with conventional meanings:

- /G/ is an ixml grammar which produces well-formed XML output
  for every string generated by the grammar.

  Note that it is possible to construct /G/ in such a way that it
  accepts some strings for which its serialization markings make a
  well-formed serialization impossible.  (One simple way is to use
  nonterminals or aliases which are not legal names in XML; another is
  to require that some element have two attributes with the same
  name.)  Such grammars are excluded from consideration here.
  
- /L(G)/ is the set of input strings accepted by /G/.

- /X(G)/ is the set of XML documents produced by a conforming ixml
  processor parsing some string in /L(G)/ against /G/ .

- /S/ is, unless otherwise specified, a schema constructed to
  approximate /X(G)/.
  
- /s/ is, unless otherwise specified, an input string.

- /d/ is, unless otherwise specified, an XML document produced by
  parsing /s/ against /G/.

The schema language of primary interest is Relax NG; other schema
languages may be mentioned in passing.

* A running example

As a running example, we will use the grammar given in the "How it
works" section of the ixml specification.  It appears in two forms,
which we will call /G_0/ and /G_1/.

#+begin_src ixml
{ Grammar G_0 }
url: scheme, ":", authority, path.

scheme: letter+.

authority: "//", host.
host: sub++".".
sub: letter+.

path: ("/", seg)+.
seg: fletter*.
-letter: ["a"-"z"]; ["A"-"Z"]; ["0"-"9"].
-fletter: letter; ".".  
#+end_src

Grammar /G_1/ uses a wider variety of ixml constructs.

#+begin_src ixml
{ Grammar G_1 }
url: scheme, -":", authority, path.

@scheme: letter+.

authority: -"//", host.
host: sub++".".
-sub: letter+.

path: ("/", seg)+.
-seg: fletter*.
-letter: ["a"-"z"]; ["A"-"Z"]; ["0"-"9"].
-fletter: letter; ".".  
#+end_src

* Constraining the element and attribute structure

Let us consider first using a schema to capture constraints on
elements and attributes in /d/, in particular constraints on their
names and position, as opposed to their character-data content.

Several different kinds of consistency between /G/ and /S/ may be
distinguished.  In most cases, the resulting /S/ will accept a
superset of /X(G)/.

** Name consistency (Waterloo schema)

/S/ is name-consistent with /G/ if and only if /S/ allows all and only
the element names and attribute names found in documents in /X(G)/.

In the simple case, /S/ imposes no further constraints.

/S/ is thus analogous to the style of document type definition
sometimes called a 'Waterloo DTD', in honor of the work of the Center
for the New Oxford English Dictionary at the University of Waterloo.
They used no DTDs at all; in their SGML-like notation, any element
could appear at any place, as could character data.  That is, Waterloo
used a precursor of what is no called well-formed XML.

The 'Waterloo DTD' was as close as one could come to describing the
format using a DTD.  Because in a DTD all elements and attributes must
be declared, a Waterloo DTD (or more generally, a Waterloo schema)
declares all element types, and allows them to contain text and any
other elements.  Attributes are declared as =CDATA= and all attributes
are declared on all element types.

The SGML form of the required declarations for an element /e/ is:
#+begin_src sgml
<!ELEMENT e ANY >
<!ATTLIST e %attributes; >
#+end_src
where the parameter entity /attributes/ is assumed to contain
declarations for all attributes to be allowed.

In XML DTDs, the keyword ~ANY~ is not available, so all the elements
in the vocabulary must be enumerated in the content model.  For
grammar /G_1/, the declarations will be:
#+begin_src xml
<!ENTITY % elements "url | authority | path | host" >
<!ENTITY % attributes "scheme CDATA #IMPLIED" >
<!ELEMENT url (#PCDATA | %elements;)* >
<!ATTLIST url %attributes; >
<!ELEMENT authority (#PCDATA | %elements;)* >
<!ATTLIST authority %attributes; >
<!ELEMENT path (#PCDATA | %elements;)* >
<!ATTLIST path %attributes; >
<!ELEMENT host (#PCDATA | %elements;)* >
<!ATTLIST host %attributes; >
#+end_src

The equivalent constructs in Relax NG and XSD are straightforward,
although they are not of much interest in any case because the
validation offered by name consistency is so weak.

When /S/ is name-consistent with /G/ (and no more), then /S/
recognizes a superset of /X(G)/.

** Parent/child consistency

/S/ is parent/child-consistent with /G/ if and only if:
- /S/ is name-consistent with /G/, and
- /S/ allows any element /C/ to occur as child of some element /P/ if
  and only if elements named /C/ appears as children of elements named
  /P/ in /X(G)/, and
- /S/ allows text nodes to occur as childredn of some element /P/ if
  and only if elements named /P/ have text-node children in some
  documents of /X(G)/, and
- /S/ allows any attribute /A/ to appear on an element /E/ only if
  attributes with the name /A/ appear on elements with the name /E/
  in /X(G)/, and
- /S/ allows any element /E/ to appear as the outermost element of a
  document if and only if elements with that name appear as the
  outermost elements of documents in /X(G)/.

(Perhaps this should be called 'vertical' consistency?)

Parent/child consistency is somewhat stricter than name consistency,
although again the set of documents accepted by /S/ is a superset of
/X(G)/.  In XML DTD notation, the schema for grammar /G_1/ might read:

#+begin_src xml
<!ELEMENT url (scheme | authority | path)* >
<!ATTLIST url schema CDATA #IMPLIED >
<!ELEMENT authority (host)* >
<!ELEMENT path (#PCDATA)* >
<!ELEMENT host (#PCDATA)* >
#+end_src

** Content-model consistency

/S/ is content-model-consistent with /G/ if and only if:
- /S/ is parent/child-consistent with /G/, and
- /S/ allows, for any parent element /P/, all and only those sequences
  of child elements which occur in /X(G)/, and allows text nodes only
  in those positions of those sequences where text nodes appear in
  /X(G)/.

[Perhaps call this 'horizontal' consistency?]

For example, in Relax NG compact syntax, the schema for /G_0/ might be:
#+begin_src rnc
start = url
url =
  element url {
    scheme,
    text,
    authority,
    path
  }
scheme = element scheme { text }
authority =
  element authority {
    text,
    host
  }
path = element path { string }
host = element host { string }  
#+end_src

In these declarations, the /text/ keyword allows text in precisely
those places where the grammar requires character data: ":" as a child
of /url/ between /scheme/ and /authority/, and "~//~" as the first
child node of /authority/ before the /host/ child, and as the only
content of /host/ and /path/.  Text nodes are not allowed elsewhere.
But RNG does not allow us to require that the text nodes consist of a
full stop or a double slash, so the RNC schema just given accepts a
superset of /X(G)/.

Any schema constructed in (XML) DTD or XSD notation will accept a
larger superset, because those notations do not provide a notation for
allowing text in some but not all locations in a content model.

The schema given above for grammar /G_0/ recognizes the correct
language, but its relation to the grammar is not completely obvious:
some nonterminals appear in the schema as names of patterns and
elements or attributes, and others disappear entirely.

A simple way to arrange a mechanical translation while remaining
relatively confident that the schema correctly matches the grammar is
to translate every nonterminal /N/ in /G/ into one ore more patterns
in /S/:

- If /N/ is ever marked hidden or serialized as an element, a pattern
  named /h.N/ is generated.  Its content is a more or less literal
  transcription of /N/'s right-hand side into RNG syntax: references
  to nonterminals turn into references to appropriately named
  patterns, terminal symbols and insertions turn into the ~text~
  keyword, and repetition operators and the like turn into the
  corresponding RNG constructs, and finally the expression is
  simplified.
  
- If /N/ is ever serialized as an element, a pattern named /e.N/ is
  generated.  It generates an element declaration with an appropriate
  name and defines its content by reference to /h.N/.  If the
  nonterminal has an alias, the alias becomes the element name;
  otherwise the nonterminal itself becomes the element name.
  
- If /N/ is ever serialized as an attribute, a pattern named /a.N/ is
  generated.  It generates an attribute declaration with the
  appropriate name (alias or nonterminal) and a content declaration of
  ~text~.
  
- If /N/ is ever referred to without an explicit mark, a pattern named
  /N/ is generated, which simply refers to /h.N/, /e.N/, or /a.N/ as
  appropriate.

Following this pattern, grammar /G_1/ can be turned into an RNG schema
along the following lines.  
#+begin_src rnc
grammar {
  start = url

  url = e.url
  e.url = element url { scheme, authority, path }

  scheme = a.scheme
  a.scheme = attribute scheme {text}

  authority = e.authority
  e.authority = element authority { host }

  host = e.host
  e.host =
    element host {
      sub,
      (text, sub)*
    }

  sub = h.sub
  h.sub = letter+

  path = e.path
  e.path =
    element path {
      (text, seg)+
    }

  seg = h.seg
  h.seg = fletter*

  letter = h.letter
  h.letter = text | text | text

  fletter = h.fletter
  h.fletter = letter | text
}
#+end_src
In the schema just given, the expression for /h.letter/ has not been
simplified, in order to illustrate the kind of simplification that may
be needed.  In principle, the expression ~(text | text | text)~ should
recognize exactly the same strings as ~text~, but although in other
cases RNG takes a relaxed attitude towards non-determinism in content
models, this particular form of non-determinism is flagged as an error.

If before generating the schema we inline all hidden nonterminals in
the grammar (and simplify expressions after or during the conversion),
then the schema becomes a little tidier:
#+begin_src ixml
grammar {
  start = url

  url = e.url
  e.url = element url { scheme, authority, path }

  scheme = a.scheme
  a.scheme = attribute scheme {text}

  authority = e.authority
  e.authority = element authority { host }

  host = e.host
  e.host =
    element host {text}

  path = e.path
  e.path = element path {text}
}

#+end_src

As noted above, the ~text~ keyword is used here to constrain the
position of textual data, but no attempt is used to make it constrain
the data.  RNG and XSD (and Schematron using XPath 2.0 or higher) do
allow the schema to use regular expressions to constrain the string
values of attributes and elements with character content.  Such
constraints relate not to the element/attribute structure of the
document but to its character data and are dealt with below.


* Constraining text nodes and attribute values

For character data, we can again identify several levels of
consistency.  In all of the kinds of consistency defined below, the
schema uses regular expressions to require that some attribute values
and some textual content match the constraints expressed in the
grammar.  Different kinds of consistency vary primarily in which
attribute values and which element content the constraints are applied
to.

** L1: directly regular constructs

For any 'directly regular' element or attribute serializing some
nonterminal /N/, /S/ accepts all and only the strings in /L(N, G)/.

Here a directly regular element or attribute is the serialization of
some nonterminal /N/ whose rule in /G/ has no nonterminal symbols on
its right-hand side.  /L(N, G)/ denotes the set of strings generated
by /N/ in grammar G.

** L2: nonrecursive constructs

For any element or attribute serializing some non-recursive
PCDATA-only nonterminal /N/, /S/ accepts all and only the strings in
/L(N, G)/.

Here a nonterminal /N/ is non-recursive if and only if /N/ is not a
possible descendant of /N/ (i.e. N is not a member of /^pc(N)/, where
/pc/ is the parent/child relation on nonterminals and /^pc/ is its
positive transitive closure), and the same holds true for all
descendants of /N/ (that is, they are also non-recursive).  A
nonterminal /N/ is PCDATA-only if (a) /N/ is serialzied as an
attribute, or (b) no member of /^pc(N)/ is serialized as an element.

[Informally: /N/ is PCDATA-only if, when /N/ is serialized as an
element, the element never has any children.]

[Note that if /N/ is non-recursive, then /L(N, G)/ is guaranteed
regular and thus expressible by a regular-expression pattern.  If the
grammar uses recursive to express iteration, /N/ may be regular
without being non-recursive.  But if all iteration is expressed in /G/
using /repeat0/ and /repeat1/, I believe /L(N, G)/ will be regular if
and only if /N/ is non-recursive.]

[Note that one might also imagine defining a level of functionality
which would involve the processor detecting recursions which could be
eliminated by rewriting the grammar using repetitions, doing so, and
constructing regular expressions from the result.  This document does
not define such a level of functionality.]

For example, at level L2, grammar /G_1/ can be approximated by the
following schema.  It is just as before, except that the values of the
/scheme/ attribute and the /sub/ and /path/ elements are constrained
as in the grammar.  The text nodes occurring between /sub/ elements
within /host/, on the other hand, are not constrained, so the schema
does not check to make sure that each such text node consists of a
single full stop.

#+begin_src ixml
grammar {
  start = url

  url = e.url
  e.url = element url { scheme, authority, path }

  scheme = a.scheme
  a.scheme =
    attribute scheme {
      xsd:string { pattern = "([a-z]|[A-Z]|[0-9])+" }
    }

  authority = e.authority
  e.authority = element authority { host }

  host = e.host
  e.host =
    element host {
      xsd:string {
        pattern = "([a-z]|[A-Z]|[0-9])+(\.([a-z]|[A-Z]|[0-9])+)*"
      }
    }

  path = e.path
  e.path =
    element path {
      xsd:string { pattern = "(/([a-z]|[A-Z]|[0-9]|\.)+)+" }
    }
}
#+end_src


** L3: regular approximations

An L3 schema /S/ satisfies these conditions:
- It satisfies the conditions of L2.
- For any element or attribute serializing some recursive PCDATA-only
  nonterminal /N/, /S/ accepts just those strings matching a regular
  approximation of /L(N, G)/.

The precise approximation chosen should be specified by the user.  As
a default, approximation U3 may be best.  U3 allows up to three
occurrences of any nonterminal N in a derivation path in the raw parse
tree.  Informally, it allows brackets up to three deep, then allows no
further brackets.

In any grammar intended for the use cases described above, the
recursive nesting in context-free languages will normally be
represented in XML by nesting elements; the ability to provide a
regular approximation of a context-free language is thus unlikely to
be very often useful in practice.  It's reassuring to know that it's
feasible in principle, but has relatively low priority.

** L4: mixed-content consistency

As for L3, and additionally /S/ includes Schematron rules for all
elements with mixed content.  The Relax NG rules allow text nodes at
appropriate locations among the children of such elements, but do not
constrain their form.  The Schematron rules define a regular
expression which matches all children, including text nodes.

Child elements are matched by writing a sole-tag with the appropriate
name into the string to match against the regular expression; to avoid
conflicts with user data containing angle brackets, the sole tag is
written using the 'tag' characters of Unicode, which are a sequence of
127 characters beginning at U+E00000, originally intended for
language-tagging in plain text and now used for locale-tagging on
emoji.  (Other mechanisms can be imagined, and some may be
preferable.)

When more than one nonterminal produces elements with the same name,
and at least one of those nonterminals produces mixed content, then
special measures are necessary to set the /context/ attribute on
Schematron rules correctly; see below.

In grammars designed for the use cases described above, mixed content
is expected to be vanishingly rare, so level-4 consistency is not
expected to be needed in practice.

# There may be a number of regularities in the XML documents produced by
# a conforming ixml processor parsing strings accepted by a given ixml
# grammar G; some schema languages can capture some of these
# regularities.  For brevity, we will say that a document or part of a
# document D is "emitted by G" if there is some input string s in L(G)
# such that D is allowed as the output of a conforming ixml processor
# parsing s against input grammar G.  


* Some complications, limitations, and gaps
This section lists some known gaps between an ideal schema for
/X(G)/ and what is practicable using RNG + Schematron.

** Aliasing for mixed-content elements
*** The difficulty:  which Schematron constraint to apply?
The aliasing feature of ixml grammars allows us to give the same
element or attribute name to two different nonterminals in the
grammar.  For example, consider grammar /G3/:
#+begin_src ixml
a = b; c.
b = '[b|', b-name, '|b]'.
c = '[c|', c-name, '|c]'.
b-name > name = 'B', [L]*.
c-name > name = 'C', [L]*.
#+end_src
A /name/ element in /X(G3)/ may be the serialization of a /b-name/ or
of a /c-name/, and the pattern it must match depends on that.  But
just as ixml allows us to distinguish the nonterminal in the grammar
from the element type name in the output, RNG allows us to specify
different element declarations with the same element type name.  (XSD
allows this, too, but its requirement for deterministic content models
makes that impossible for this case.)

An RNG schema for grammar /G3/ might read:
#+begin_src rnc
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

start = a
a = element a { (b | c)* }
b = element b { text, b-name, text }
c = element c { text, c-name, text }
b-name =
  element name {
    xsd:string { pattern = "B\p{L}*" }
  }
c-name =
  element name {
    xsd:string { pattern = "C\p{L}*" }
  }
#+end_src
We can extend this with Schematron rules requiring that /b/ elements
begin with a text node reading "[b|" and end with a text node
reading "|b]", and that /c/ elements similarly begin and end with
"[c| " and "|c]".  The schema /S/ then matches /X(G)/ correctly.

But now consider /G4/, in which both /b/ and /c/ are serialized using
the same element name (/d/):
#+begin_src ixml
a = b+, c+.
b > d = '[b|', b-name, '|b]'.
c > d = '[c|', c-name, '|c]'.
b-name > name = 'B', [L]*.
c-name > name = 'C', [L]*.
#+end_src

The only difference in the RNG schemas for /G3/ and /G4/ is in the
definition of patterns /b/ and /c/, which now specify a different name
for the element:
#+begin_src rnc
b = element d { text, b-name, text }
c = element d { text, c-name, text }  
#+end_src
If we also show the associated Schematron rules, it will be easier to
read in the XML form:
#+begin_src rng
    <define name="b">
        <element name="d">
            <sch:rule context="d">
                <sch:assert test="'[b|&#xE003C;name&#xE002F;&#xE003E;|b]'
                    eq
                    string-join(
                    for $c in ./child::node()
                    return
                    if ($c instance of element())
                    then concat('&#xE003C;', name($c), '&#xE002F;&#xe003E;')
                    else if ($c instance of text())
                    then string($c)
                    else ''
                    )"></sch:assert>
            </sch:rule>
            <group>
                <text/>
                <ref name="b-name"/>
                <text/>
            </group>
        </element>
        
    </define>
    <define name="c">
        <element name="d">
            <sch:rule context="d">
                <sch:assert test="'[c|&#xE003C;name&#xE002F;&#xE003E;|c]'
                    eq
                    string-join(
                    for $c in ./child::node()
                    return
                    if ($c instance of element())
                    then concat('&#xE003C;', name($c), '&#xE002F;&#xe003E;')
                    else if ($c instance of text())
                    then string($c)
                    else ''
                    )"></sch:assert>
            </sch:rule>
            <group>
                <text/>
                <ref name="c-name"/>
                <text/>
            </group>
        </element>
    </define>
#+end_src
Now consider an XML document to be validated against a schema for /X(G4)/:
#+begin_src xml
<a>
    <d><name>Ba</name></d>
    <d><name>Bb</name></d>
    <d><name>Ca</name></d>
    <d><name>Cb</name></d>
</a>
#+end_src
Grammar G4 requires that all occurrences of /b-name/ precede all occurrence
of /c-name/; the RNG schema can enforce this rule, and object if the fourth
/name/ element in the document has the value "Bc".  If the second /name/ element
has the value "X", an RNG validator can say that the value must match either
the regular expression "B\p{L}*" or the expression "C\p{L}".

But we cannot use Schematron here to enforce the rule that a name
whose value starts with a "B" must be preceded by "[b|" and followed
by "|b]", and one starting with "C" must have "[c|" and "|c]".  In an
RNG schema, Schematron rules may be attached to particular patterns
and thus to particular element declarations within those patterns but
the application of the Schematron rule is governed by the XPath match
pattern given as the value of the /context/ attribute, and not by any
connection made by a schema validator between a particular pattern in
the schema and a particular element in the XML document being
validated.  (I am here following the explanation offered by Eric van
der Vlist; I have no independent knowledge of the Schematron
specification.)  The upshot is that in this case, we end up with two
Schematron rules, one applicable to some elements and the other to
other elements, with no way for the Schematron validator to know which
rule goes with which element.

*** When this difficulty arises
This problem arises when the following conditions are met:

1. More than one nonterminal in /G/ is serialized with the same
   element type name.

2. The grammar rules for these nonterminals differ.
    
3. At least one of those nonterminals produces mixed content.

Because of 3, we will want to generate a Schematron rule to check the
mixed content.  Because of 1 and 2, however, any Schematron rule we
generate will be applicable to some but not all elements with the
given element type name.  There appears to be no straightforward way
to apply each Schematron rule we generate to the appropriate elements.

*** Sketch of a solution
In principle, this is a soluble problem.  In practice, the solution
may require more effort than it is worth, since the problem can be
avoided by eliminating mixed content in aliased elements.

Assume that some set of nonterminals /N_1/, /N_2/, ..., /N_n/ all
produce elements with the same name /e/.

- Each nonterminal /N/ generates some set of elements in /X(G)/.

- It ought in principle to be possible to construct an XPath
  expression that matches all and only those elements in /X(G)/ which
  could (based on their context) be serializations of some instance of
  /N/.

  For future reference, let us call these the base XPath expressions.

- Some elements with the name /e/ may match the XPath expression for
  exactly one /N_i/; in that case, the associated Schematron
  constraints should be applied to those elements.

- Some elements may match the XPath expression for more than one
  /N_i/; in that case, the constraint applied should be the
  disjunction of the constraints for the matching nonterminals.
  
  For example, if an element matches both /N_1/ and /N_2/, and the
  Schematron constraints for those nonterminals are /t_1/ and /t_2/,
  respectively, then the constraint to be applied to the element is
  (/t_1/ ∨ /t_2/).
  
  (This is possible because neither ixml nor RNG require grammar rules
  or content models to be deterministic or unambiguous.)

- In a given Schematron 'pattern' (or group of rules), the first rule
  with a matching /context/ fires, and no other is consulted.

  To associate Schematron rules correctly with element instances,
  therefore, it is necessary to make an XPath expression for each
  /N/_/i/ which matches only serializations of that nonterminal and no
  serializations of any other nonterminal in the set, and an XPath
  expression for each possible combination of nonterminal matched.

  For example, if three nonterminals (/N_1/, /N_2/, and /N_3/)
  are
  serialized as elements with name /e/, we will need XPath
  expressions which match
  + /N_1/ (and neither of the others)
  + /N_2/ (and neither of the others)
  + /N_3/ (and neither of the others)
  + /N_1/ or /N_2/ (but not /N_3/)
  + /N_1/ or /N_3/ (but not /N_2/)
  + /N_2/ or /N_3/ (but not /N_1/)
  + any of /N_1/, /N_2/, or /N_3/ 

  We can construct these by combining the base XPath expressions (call
  them /X_1/, /X_2/, and /X_3/) using XPath set operations:

  + /N_1/ (and neither of the others):  /X_1/ except (/X_2/ | /X_3/)
  + /N_2/ (and neither of the others):  /X_2/ except (/X_1/ | /X_3/)
  + /N_3/ (and neither of the others):  /X_3/ except (/X_1/ | /X_2/)
  + /N_1/ or /N_2/ (but not /N_3/):  (/X_1/ | /X_2/) except /X_3/ 
  + /N_1/ or /N_3/ (but not /N_2/):  (/X_1/ | /X_3/) except /X_2/ 
  + /N_2/ or /N_3/ (but not /N_1/):  (/X_2/ | /X_3/) except /X_1/ 
  + /N_1/ or /N_2/ or /N_3/:  /X_1/ | /X_2/ | /X_3/

*** Some supporting theorems
Is it in fact possible to construct the base XPath expressions needed
in the solution sketched above?  I think the answer is yes.

/Theorem:/ For any nonterminal /N/ in /G/ the set of ancestor paths of
/N/ (i.e. paths from the root of the raw parse tree [not the
serialized XML] to an instance of /N/) is a regular language.

/Proof:/ We can construct a finite state automaton /A/ = (/Q/, Σ, δ,
/q/_0, /F/), with
- /Q/ = the set of nonterminals in /G/
- Σ = the set of nonterminals in /G/
- δ = the set of triples (/P/, /C/, /C/) where nonterminal /C/
  appears in the right-hand side of nonterminal /P/.
- /q/_0
  is the start symbol of
  /G/
- /F/ = {/N/}

It is evident that the set of strings accepted by this FSA is the set
of paths in raw parse trees beginning at the start symbol and ending
at /N/.

/Corollary:/ For any nonterminal /N/ in /G/ serialized as an element
named /e/ or an attribute named /a/, it is possible to construct an
XPath expression which matches only those /e/ elements or /a/
attributes whose ancestry matches that of elements or attributes in
/X(G)/ serialized from occurrences of /N/.

/Proof:/ In the FSA described above, split the state for each
nonterminal /N/ into three states, one each for /N/ serialized as
element, serialized as attribute, and hidden.  Ajust the transitions
accordingly.  The final state has now been split into three states;
drop the hidden-nonterminal state from the set /F/.  Then change every
transition to a hidden nonterminal to an empty transition, and delete
every transition out of any nonterminal serialized as an attribute.
For every nonterminal /N/ serialized using an alias /A/, change the
symbol in all incoming arcs to state /N/ to read /A/ instead of /N/.

From this modified FSA, we can construct a regular expression matching
all and only the paths leading to serializations of /N/ as an element,
and a second one matching all and only the paths leading to
serializations of /N/ as an attribute, and we can construct an XPath
expression which constructs a string describing the ancestry of any
element or attribute.  The XPath expression will match all
serializations of /N/ as attributes or elements, and also other
elements named /e/ and attributes named /a/ which share the same
ancestry but are serializations of some other nontterminal (if there
are any such).

For example, the serializations of nonterminal /b/ in grammar /G4/
can be matched by the expression
#+begin_src xpath
//e['/' || stringjoin(ancestor-or-self::*/name(), '/')
    eq
    '/a/d']
#+end_src

/[Better example would be helpful, but the grammars given above are
all too simple.]/

/Theorem:/ For any occurrence of nonterminal /N/ in a right-hand side
of /G/, where /N/ is serialized as an element /e/, it is possible to
construct an XPath expression matching all and only elements /e/ whose
preceding element siblings match the preceding siblings of some
element /e/ in /X(G)/ serialized from an instance of /N/ with the same
ancestry.

/Proof:/ Without loss of generality, assume that there are no hidden
nonterminals in the right-hand side containing /N/.  (See below for
cases where this is not given a priori.)  If all terminal symbols and
all nonterminals to be serialized as attributes are deleted from the
expression, what remains is a regular expressoin over non-hidden
nonterminals.  This regular expression can be transformed into a
finite state automaton using standard methods.  If in that FSA the set
of final states is changed to include only the occurrences of /N/, the
FSA will accept all and only the left-to-right paths through the
content model which terminate in /N/.  A regular expression can be
constructed from that FSA, and from that regular expression an XPath
expression, along the lines shown above for the ancestry expression.

(It may be possible to construct the regular expression more directly,
but I don't currently see a clean way to do so.)

If the assumption does not hold, it can be made to hold by inlining
the definitions of the hidden nonterminals until either (a) there are
no more hidden nonterminals, or (b) the only remaining hidden
nonterminals are recursive but lack any descedants serialized as
elements.  In case (a), the assumption now holds.  In case (b) the
remaining hidden nonterminals can simply be deleted.  Since they
generate only character data, and character data is ignored in the
construction of the XPath expression, they cannot affect the XPath
expression.

/Corollary:/ For any nonterminal /N/ serialized as an element, it is
possible to construct an XPath expression which matches all elements
serialized from /N/ and no elements which do not have the same upper
and left context as some of those elements.

/Proof:/ Follows immediately.  The two XPath expressions described
above can be combined to select only elements whose ancestry and left
context are both suitable.

