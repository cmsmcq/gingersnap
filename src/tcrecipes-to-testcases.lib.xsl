<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:gt="http://blackmesatech.com/2020/grammartools"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:gl="http://blackmesatech.com/2019/iXML/Gluschkov"
    xmlns:rtn="http://blackmesatech.com/2020/iXML/recursive-transition-networks"
    xmlns:follow="http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"
    default-mode="make-test-cases"
    exclude-result-prefixes="gt xs gl rtn follow"
    version="3.0">

  <!--* trecipes-to-testcases.xsl  Read test-case recipes grammar,
      * write out test cases, as XML.
      *
      *-->

  <!--* Revisions:
      * 2021-01-23 : CMSMcQ : split codepoint-serialization functions 
      *                       out into library. 
      * 2020-12-28 : CMSMcQ : split into main and module 
      * 2020-12-26 : CMSMcQ : begin writing this, with long comment
      *                       to clear my mind.
      *-->

  <!--* Immediate plan of attack:
      * Generate test-set container, documentation, and test cases.
      * In test-case generation, push choice of characters for
      * inclusions and exclusions to a function.
      * First version of the function is trivial and mechanical.
      * Later versions are better (e.g. allow config file with
      * strings to try).
      *-->

  <!--****************************************************************
      * Setup
      ****************************************************************
      *-->
  
  <xsl:mode name="make-test-cases" on-no-match="shallow-skip"/>


  <!--****************************************************************
      * Main / starting template
      ****************************************************************
      *-->
  <!--* With a default identity transform, we don't actually need a
      * main starting template.  But we do want one for ixml, to
      * inject a comment to identify the stylesheet.
      *-->
  <xsl:template match="ixml">

    <xsl:element name="test-set">
      <xsl:attribute name="gt:date" select="current-dateTime()"/>
      <xsl:call-template name="test-set-header"/>
      <xsl:apply-templates/>
    </xsl:element>

  </xsl:template>


  <xsl:template match="rule[@gt:polarity]/alt">
    <testcase>
      <xsl:attribute name="gt:rulename" select="../@name"/>
      <xsl:sequence select="../@gt:polarity, @gt:trace"/>
      <input-string>
	<xsl:sequence select="gt:serialize(*)"/>
      </input-string>
    </testcase>    
  </xsl:template>

  <!--****************************************************************
      * Named templates
      ****************************************************************
      *-->
  <xsl:template name="test-set-header">
    <desc>
      <p>This document contains tests for the language defined
      by [what grammar?], generated by an as yet nameless set
      of test-case generation tools.</p>
      <p>Test polarity:  <xsl:value-of select="@gt:test-polarity"/>.</p>
      <p>Test selection:  <xsl:value-of select="@gt:test-selection"/>.</p>
    </desc>    
  </xsl:template>
  

  <!--****************************************************************
      * Functions
      ****************************************************************
      *-->
 

  <!--****************************************************************
      * Predicates 
      *-->    

</xsl:stylesheet>
